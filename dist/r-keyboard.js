(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["RKeyboard"] = factory();
	else
		root["RKeyboard"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  /**\n   * This keyboard's keymap.\n   *\n   * Link easy-to-remember KeyNames to their respective keyCode(s).\n   *\n   * This is an object where:\n   *   1. The keys are the keyCodes (as in event's keyCode)\n   *   2. The values are the names as used in the webapp.\n   * @type Object\n   */\n  KEY_MAP: {\n    8: 'Back',\n    // Backspace\n    9: 'Tab',\n    // Tab\n    13: 'Enter',\n    // Enter\n    16: 'Shift',\n    // Shift\n    17: 'Ctrl',\n    // Control\n    18: 'Alt',\n    // Alt\n    19: 'Pause',\n    // Pause/Break\n    20: 'Caps',\n    // Caps Lock\n    27: 'Esc',\n    // Escape\n    32: 'Space',\n    // Space\n    33: 'PageUp',\n    // Page Up\n    34: 'PageDown',\n    // Page Down\n    35: 'End',\n    // End\n    36: 'Home',\n    // Home\n    37: 'Left',\n    // Left arrow\n    38: 'Up',\n    // Up arrow\n    39: 'Right',\n    // Right arrow\n    40: 'Down',\n    // Down arrow\n    45: 'Insert',\n    // Insert\n    46: 'Delete',\n    // Delete\n    48: 'Num0',\n    // 0\n    49: 'Num1',\n    // 1\n    50: 'Num2',\n    // 2\n    51: 'Num3',\n    // 3\n    52: 'Num4',\n    // 4\n    53: 'Num5',\n    // 5\n    54: 'Num6',\n    // 6\n    55: 'Num7',\n    // 7\n    56: 'Num8',\n    // 8\n    57: 'Num9',\n    // 9\n    65: 'a',\n    // a\n    66: 'b',\n    // b\n    67: 'c',\n    // c\n    68: 'd',\n    // d\n    69: 'e',\n    // e\n    70: 'f',\n    // f\n    71: 'g',\n    // g\n    72: 'h',\n    // h\n    73: 'i',\n    // i\n    74: 'j',\n    // j\n    75: 'k',\n    // k\n    76: 'l',\n    // l\n    77: 'm',\n    // m\n    78: 'n',\n    // n\n    79: 'o',\n    // o\n    80: 'p',\n    // p\n    81: 'q',\n    // q\n    82: 'r',\n    // r\n    83: 's',\n    // s\n    84: 't',\n    // t\n    85: 'u',\n    // u\n    86: 'v',\n    // v\n    87: 'w',\n    // w\n    88: 'x',\n    // x\n    89: 'y',\n    // y\n    90: 'z',\n    // z\n    91: 'Window',\n    // Left window key\n    92: 'Window',\n    // Right window key\n    93: 'Select',\n    // Select key\n    96: 'Num0',\n    // numpad 0\n    97: 'Num1',\n    // numpad 1\n    98: 'Num2',\n    // numpad 2\n    99: 'Num3',\n    // numpad 3\n    100: 'Num4',\n    // numpad 4\n    101: 'Num5',\n    // numpad 5\n    102: 'Num6',\n    // numpad 6\n    103: 'Num7',\n    // numpad 7\n    104: 'Num8',\n    // numpad 8\n    105: 'Num9',\n    // numpad 9\n    106: 'Multiply',\n    // *\n    107: 'Add',\n    // +\n    109: 'Subtract',\n    // -\n    110: 'DecimalPoint',\n    // .\n    111: 'Divide',\n    // Divice\n    112: 'f1',\n    // f1\n    113: 'f2',\n    // f2\n    114: 'f3',\n    // f3\n    115: 'f4',\n    // f4\n    116: 'f5',\n    // f5\n    117: 'f6',\n    // f6\n    118: 'f7',\n    // f7\n    119: 'f8',\n    // f8\n    120: 'f9',\n    // f9\n    121: 'f10',\n    // f10\n    122: 'f11',\n    // f11\n    123: 'f12',\n    // f12\n    144: 'NumLock',\n    // Num Lock\n    145: 'ScrollLock',\n    // Scroll Lock\n    186: 'SemiColon',\n    // ;\n    187: 'Equal',\n    // =\n    188: 'Comma',\n    // ,\n    189: 'Dash',\n    // -\n    190: 'Point',\n    // .\n    191: 'Slash',\n    // .\n    192: 'BackTick',\n    // `\n    219: 'OpenBracket',\n    // {\n    220: 'BackSlash',\n    // \\\n    221: 'CloseBracket',\n    // }\n    223: 'SingleQuote' // '\n\n  },\n\n  /**\n   * Grouping of KeyNames, that can be used as a shortcut instead of each of its\n   * keynames in the keyboard.\n   *\n   * @type {Object}\n   */\n  GROUPINGS: {\n    Nums: ['Num0', 'Num1', 'Num2', 'Num3', 'Num4', 'Num5', 'Num6', 'Num7', 'Num8', 'Num9'],\n    Directions: ['Up', 'Down', 'Left', 'Right'],\n    Letters: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  },\n\n  /**\n   * Default value for the Keyboard propagate option, allowing - or not - a\n   * keyboard call for specific keys to be propagated through precedent ones.\n   *\n   * Basically:\n   *   - If set to false, the last listener is the only one to catch the wanted\n   *     keys by default (not propagated to the next listener).\n   *\n   *   - If set to true, we call the callbacks from the last to the first\n   *     listeners by default.\n   *\n   * Bear in mind that:\n   *   - a propagate option can still be defined for each listener.\n   *   - even if propagating, a propagation can still stop via\n   *     this.stopPropagation on listeners.\n   * @type Boolean\n   */\n  DEFAULT_PROPAGATE_VALUE: true,\n\n  /**\n   * Default value for the Keyboard combine option, allowing - or not -\n   * multiple simultaneous keydown to be processed simultaneously.\n   *\n   * You can set it to false to emulate the real 'keydown' events.\n   *\n   * Basically:\n   *   - If set to false:\n   *       1. The last key pushed will interrupt the eventual press events from\n   *          all the other keys held (a release event will still be sent on\n   *          release from every key).\n   *       2. If the reEmit option is activated, only the last key held will be\n   *          reEmitted.\n   *\n   *   - If set to true:\n   *       1. Every keys will emit push, press and release events, even if\n   *          multiple keys are pushed simultaneously.\n   *       2. If the reEmit option is activated, every held keys will be\n   *          reEmitted on a row (from the oldest to the newest).\n   *\n   * @type Boolean\n   */\n  DEFAULT_COMBINE_VALUE: true,\n\n  /**\n   * Interval, in ms, to which we should reEmit a key 'push' event if the key\n   * was pushed before the listener was added (in the condition the key was not\n   * released since).\n   *\n   * Basically:\n   *   - If inferior to 0, only key(s) pushed after the listener declaration\n   *     will trigger events.\n   *   - If set to a value >=0, key(s) pushed before the declaration will be\n   *     reEmitted after this value * 1ms (if the key(s) is/are still held).\n   *     Note: whether multiple keys are re-sent also depends on the\n   *     'combine' option.\n   */\n  DEFAULT_REEMIT_VALUE: 500,\n  DEFAULT_PREVENT_DEFAULT: false\n});\n\n//# sourceURL=webpack://RKeyboard/./src/config.js?");

/***/ }),

/***/ "./src/events.js":
/*!***********************!*\
  !*** ./src/events.js ***!
  \***********************/
/*! exports provided: KEYCODES_PUSHED, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KEYCODES_PUSHED\", function() { return KEYCODES_PUSHED; });\n/* harmony import */ var _misc_isSet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./misc/isSet */ \"./src/misc/isSet.js\");\n/**\n * This file proposes a supplementary layer over the builtins addEventListener\n * and removeEventListener functions.\n *\n * It provides two functions:\n *   - on\n *   - off\n *\n * Which wrap respectively the addEventListener and removeEventListener\n * functions with some differences:\n *\n *   - Only works for 'keydown' and 'keyup' events.\n *\n *   - Only emit the first keydown when the key is held (not released).\n *\n *   - You must define the keyCodes listened to, and you are only notified for\n *     the events for those keys.\n *\n *   - Multiple `on` call for the same callback will bind only the last one\n *     declared.\n *\n *   - The callback will have as argument the keyCode of the key pushed.\n *\n * Please note that this file perform three addEventListener when parsed.\n */\n\n/**\n * Array containing every key pushed.\n * Used by addKeyPushedToArray / removeKeyPushedFromArray / isKeyPushed.\n * Used to avoid sending two times in a row a keydown event for the same key.\n * @type Array.<Number>\n * TODO HashMap\n */\n\nvar KEYCODES_PUSHED = [];\n/**\n * Add keyCode to the KEYCODES_PUSHED array.\n *\n * Used to be able to know if the key is currently pushed through the\n * isKeyPushed function.\n * @param {Number} keyCode\n */\n\nvar addKeyPushedToArray = function addKeyPushedToArray(keyCode) {\n  KEYCODES_PUSHED.push(keyCode);\n};\n/**\n * Remove keyCode from the KEYCODES_PUSHED array.\n *\n * Used to be able to know if the key is currently pushed through the\n * isKeyPushed function.\n * @param {Number} keyCode\n */\n\n\nvar removeKeyPushedFromArray = function removeKeyPushedFromArray(keyCode) {\n  for (var i = KEYCODES_PUSHED.length - 1; i >= 0; i--) {\n    if (KEYCODES_PUSHED[i] === keyCode) {\n      KEYCODES_PUSHED.splice(i, 1);\n      return;\n    }\n  }\n};\n/**\n * Register every 'keydown' callbacks added through addKeyEventListener, as well\n * as their registered keyCodes.\n *\n * Used to keep track of it as a addEventListener is only done one time\n * in our application and we never perform any removeEventListener.\n * @type Array.<Function>\n */\n\n\nvar keyDownCallbacks = [];\n/**\n * Register every 'keyup' callbacks added through addKeyEventListener, as well\n * as their registered keyCodes.\n *\n * Used to keep track of it as a addEventListener is only done one time\n * in our application and we never perform any removeEventListener.\n * @type Array.<Function>\n */\n\nvar keyUpCallbacks = [];\n\nvar listen = function listen(keyCodes, _temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      preventDefault = _ref.preventDefault;\n\n  // keep track of which callbacks were added through this listen call\n  var localKeyDownCallbacks = [];\n  var localKeyUpCallbacks = [];\n  var isClosed = false;\n  /**\n   * Add new callback for a 'keydown' event on a webapp key\n   * If the same callback was already registered, replace it.\n   * @param {Array.<Number>} keyCodes\n   * @param {Function} - callback\n   */\n\n  var addKeyDownListener = function addKeyDownListener(callback) {\n    // if we already registered the same callback here, return\n    for (var i = localKeyDownCallbacks.length - 1; i >= 0; i--) {\n      if (localKeyDownCallbacks[i].callback === callback) {\n        return;\n      }\n    }\n\n    var localKeyDownCallback = {\n      keyCodes: keyCodes,\n      callback: callback\n    };\n    localKeyDownCallbacks.push(localKeyDownCallback);\n    keyDownCallbacks.push(localKeyDownCallback);\n  };\n  /**\n   * Add new callback for a 'keyup' event on a webapp key.\n   * If the same callback was already registered, replace it.\n   * @param {Array.<Number>} keyCodes\n   * @param {Function} - callback\n   */\n\n\n  var addKeyUpListener = function addKeyUpListener(callback) {\n    // if we already registered the same callback here, return\n    for (var i = localKeyUpCallbacks.length - 1; i >= 0; i--) {\n      if (localKeyUpCallbacks[i].callback === callback) {\n        return;\n      }\n    }\n\n    var localKeyUpCallback = {\n      keyCodes: keyCodes,\n      callback: callback\n    };\n    localKeyUpCallbacks.push(localKeyUpCallback);\n    keyUpCallbacks.push(localKeyUpCallback);\n  };\n  /**\n   * Remove callback for a 'keydown' event on a webapp key.\n   * @param {Function} - callback\n   */\n\n\n  var removeKeyDownListener = function removeKeyDownListener(callback) {\n    for (var i = localKeyDownCallbacks.length - 1; i >= 0; i--) {\n      if (localKeyDownCallbacks[i].callback === callback) {\n        var indexOf = keyDownCallbacks.indexOf(localKeyDownCallbacks[i]);\n        localKeyDownCallbacks.splice(i, 1);\n        keyDownCallbacks.splice(indexOf, 1);\n        return;\n      }\n    }\n  };\n  /**\n   * Remove callback for a 'keyup' event on a webapp key.\n   * @param {Function} - callback\n   */\n\n\n  var removeKeyUpListener = function removeKeyUpListener(callback) {\n    for (var i = localKeyUpCallbacks.length - 1; i >= 0; i--) {\n      if (localKeyUpCallbacks[i].callback === callback) {\n        var indexOf = keyUpCallbacks.indexOf(localKeyUpCallbacks[i]);\n        localKeyUpCallbacks.splice(i, 1);\n        keyUpCallbacks.splice(indexOf, 1);\n        return;\n      }\n    }\n  };\n\n  var removeAllListeners = function removeAllListeners() {\n    for (var i = localKeyDownCallbacks.length - 1; i >= 0; i--) {\n      var indexOf = keyDownCallbacks.indexOf(localKeyDownCallbacks[i]);\n      localKeyDownCallbacks.splice(i, 1);\n      keyDownCallbacks.splice(indexOf, 1);\n    }\n\n    for (var _i = localKeyUpCallbacks.length - 1; _i >= 0; _i--) {\n      var _indexOf = keyUpCallbacks.indexOf(localKeyUpCallbacks[_i]);\n\n      localKeyUpCallbacks.splice(_i, 1);\n      keyUpCallbacks.splice(_indexOf, 1);\n    }\n  };\n\n  var preventDefaultCallback = function preventDefaultCallback(evt) {\n    if (keyCodes.includes(getKeyCode(evt))) {\n      evt.preventDefault();\n    }\n  };\n\n  if (preventDefault) {\n    document.addEventListener('keydown', preventDefaultCallback);\n    document.addEventListener('keyup', preventDefaultCallback);\n  }\n\n  return {\n    on: function on(event, callback) {\n      if (isClosed && preventDefault) {\n        document.addEventListener('keydown', preventDefaultCallback);\n        document.addEventListener('keyup', preventDefaultCallback);\n      }\n\n      switch (event) {\n        case 'keydown':\n          addKeyDownListener(callback);\n          break;\n\n        case 'keyup':\n          addKeyUpListener(callback);\n          break;\n      }\n    },\n    off: function off(event, callback) {\n      switch (event) {\n        case 'keydown':\n          removeKeyDownListener(callback);\n          break;\n\n        case 'keyup':\n          removeKeyUpListener(callback);\n      }\n    },\n    close: function close() {\n      removeAllListeners();\n      document.removeEventListener('keydown', preventDefaultCallback);\n      document.removeEventListener('keyup', preventDefaultCallback);\n      isClosed = true;\n    }\n  };\n};\n/**\n * Trigger every callbacks registered for the 'keydown' events with the\n * right arguments.\n *\n * @param {Number} keyCode\n */\n\n\nvar triggerKeyDownEvent = function triggerKeyDownEvent(keyCode) {\n  keyDownCallbacks.forEach(function (kdc) {\n    if (kdc.keyCodes.includes(keyCode)) {\n      kdc.callback(keyCode);\n    }\n  });\n};\n/**\n * Trigger every callbacks registered for the 'keyup' events with the\n * right arguments.\n *\n * @param {Number} keyCode\n */\n\n\nvar triggerKeyUpEvent = function triggerKeyUpEvent(keyCode) {\n  keyUpCallbacks.forEach(function (kuc) {\n    if (kuc.keyCodes.includes(keyCode)) {\n      kuc.callback(keyCode);\n    }\n  });\n};\n\nvar getKeyCode = function getKeyCode(evt) {\n  var keyCode = evt.keyCode;\n  return Object(_misc_isSet__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(keyCode) ? keyCode : evt.which;\n};\n/**\n * Callback for the keydown event.\n * @param {Object} evt\n */\n\n\nvar onKeyDown = function onKeyDown(evt) {\n  var keyCode = getKeyCode(evt); // if the key is already pushed, quit, we have our own mean for consecutive\n  // keydowns\n\n  if (isKeyPushed(keyCode)) {\n    return;\n  } // Consider the key as pushed from there\n\n\n  addKeyPushedToArray(keyCode); // start sending keydown events\n\n  triggerKeyDownEvent(keyCode);\n};\n/**\n * Callback for the keyup event.\n * @param {Object} evt\n */\n\n\nvar onKeyUp = function onKeyUp(evt) {\n  var keyCode = getKeyCode(evt); // Consider the key as released from there.\n\n  removeKeyPushedFromArray(keyCode); // send keyup event\n\n  triggerKeyUpEvent(keyCode);\n};\n/**\n * Returns true if the key from the given keyCode is considered pushed.\n *\n * Note: The keyCode has to be added / removed through the addKeyPushedToArray /\n * removeKeyPushedFromArray functions for this to work.\n * @returns {Boolean}\n */\n\n\nvar isKeyPushed = function isKeyPushed(keyCode) {\n  return KEYCODES_PUSHED.includes(keyCode);\n}; // add event listeners\n\n\ndocument.addEventListener('keydown', onKeyDown);\ndocument.addEventListener('keyup', onKeyUp); // when not focusing the current window, release every keys to avoid having an\n// infinite keydown.\n// /!\\ seems to not working well when changing tabs on chrome, sadly\n\nwindow.addEventListener('blur', function () {\n  // ugly but does the job\n  KEYCODES_PUSHED.forEach(function (keyCode) {\n    return onKeyUp({\n      keyCode: keyCode,\n      preventDefault: function preventDefault() {}\n    });\n  });\n});\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (listen);\n\n//# sourceURL=webpack://RKeyboard/./src/events.js?");

/***/ }),

/***/ "./src/implementations/default.js":
/*!****************************************!*\
  !*** ./src/implementations/default.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _keyboard_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../keyboard.js */ \"./src/keyboard.js\");\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n/**\n * Default Keyboard implementation.\n *\n * @example\n * ```js\n * import RKeyboard from 'rkeyboard';\n *\n * const keyboard = Rkeyboard();\n *\n * // trigger a callback for the 'Up' key keydown events\n * const keyListener = keyboard('Up',  {\n *  onPush: (e) => {\n *    // 'push' as it is the only event listened here\n *    console.log(e.event);\n *\n *    // 'Up' as it is the only key listened to here\n *    console.log(e.keyName);\n *\n *    // Time the key has been pushed in ms (0 for 'push' events)\n *    console.log(e.timepress);\n *\n *    // ...\n *  }\n * });\n *\n * // Doing the same for multiple keys ('Up' OR 'Enter')\n * const upAndEnter = keyboard(['Up', 'Enter'], {\n *   onPush: (e) => {\n *     console.log(`${e.keyName} pushed!`);\n *   }\n * });\n *\n * // Doing something on keyup\n * const upAndEnterRelease = keyboard(['Up', 'Enter'], {\n *   onRelease: (e) => {\n *     // 'release'\n *     console.log(e.event);\n *\n *     console.log(`${e.keyName} released!`);\n *   }\n * });\n *\n * // Doing the same for all keys\n * const upAndEnter = keyboard(null, {\n *   onRelease: (e) => {\n *     console.log(`${e.keyName} released!`);\n *   }\n * });\n *\n * // add custom key press rules for the 'Up' key\n * const withPress = keyboard('Up', {\n *   press: {\n *     after: 1000,\n *     interval: 2000\n *   },\n *   onPress: (e) => {\n *     // 'press'\n *     console.log(e.event);\n *\n *     console.log(`${e.keyName} pressed!`);\n *   }\n * });\n *\n * // what if we want press rules for ALL keys?\n * // We again ignore the first argument.\n * const allKeysWithPress = keyboard({\n *   press: {\n *     after: 1000,\n *     interval: 2000\n *   },\n *\n *   // catch all events (push+press+release)\n *   onEvent: (e) => {\n *     // ...\n *   },\n *\n *   // catch 'down' events (push+press)\n *   onDown: (e) => {\n *     // ...\n *   }\n * });\n *\n * // -- start and stop listening to keys --\n *\n * // first listen to the key and store the returned object\n * const myKeyListener = keyboard('Up', { onPush: () => {} });\n *\n * // free the event listener\n * myKeyListener.unbind();\n * ```\n */\n\nfunction RKeyboard(opt) {\n  var kb = Object(_keyboard_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(opt);\n\n  var callIfExist = function callIfExist(cb, evt) {\n    return cb && cb(evt);\n  };\n\n  var getArgs = function getArgs(arg1, arg2) {\n    if (Array.isArray(arg1) || typeof arg1 === 'string') {\n      return {\n        keys: arg1,\n        options: arg2\n      };\n    }\n\n    return {\n      options: arg1\n    };\n  };\n\n  return {\n    listen: function listen() {\n      var _getArgs = getArgs.apply(void 0, arguments),\n          keys = _getArgs.keys,\n          _getArgs$options = _getArgs.options,\n          options = _getArgs$options === void 0 ? {} : _getArgs$options;\n\n      var onPush = options.onPush,\n          onRelease = options.onRelease,\n          onPress = options.onPress,\n          onDown = options.onDown,\n          onEvent = options.onEvent,\n          onUnbind = options.onUnbind,\n          keyOptions = _objectWithoutPropertiesLoose(options, [\"onPush\", \"onRelease\", \"onPress\", \"onDown\", \"onEvent\", \"onUnbind\"]);\n\n      var stopListening = kb.listen(keys, keyOptions, function (evt) {\n        switch (evt.event) {\n          case 'push':\n            callIfExist(onPush, evt);\n            callIfExist(onDown, evt);\n            break;\n\n          case 'press':\n            callIfExist(onPress, evt);\n            callIfExist(onDown, evt);\n            break;\n\n          case 'release':\n            callIfExist(onRelease, evt);\n            break;\n        }\n\n        callIfExist(onEvent, evt);\n      });\n      return {\n        unbind: function unbind() {\n          callIfExist(onUnbind);\n          stopListening();\n        }\n      };\n    },\n    free: function free() {\n      kb.close();\n    }\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (RKeyboard());\n\n//# sourceURL=webpack://RKeyboard/./src/implementations/default.js?");

/***/ }),

/***/ "./src/implementations/rx.js":
/*!***********************************!*\
  !*** ./src/implementations/rx.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _keyboard_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../keyboard.js */ \"./src/keyboard.js\");\n\n/**\n * Adapt the Keyboard to the RxJS architecture by transforming listening\n * requests into Observer functions.\n *\n * @type {Object}\n * @example\n * import { RxKeyboard } from 'Keyboardjs';\n * import { Observable } from 'rxjs';\n *\n * const kb = RxKeyboard.create();\n *\n * // start listening\n * new Observable(kb(['Enter', 'Up', 'Down']))\n *   .subscribe((e) => {\n *     // ...\n *   });\n *\n * // to stop listening, just unsubscribe from the Observable\n * const sub = rx.Observable.create(kb()).subscribe();\n * sub.unsubscribe();\n */\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  create: function create() {\n    var kb = Object(_keyboard_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return kb.apply(void 0, args.concat(function (evt) {\n        return function (obs) {\n          obs.next(evt);\n          return kb();\n        };\n      }));\n    };\n  }\n});\n\n//# sourceURL=webpack://RKeyboard/./src/implementations/rx.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: RKeyboard, RxKeyboard, createKeyboard, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _misc_polyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./misc/polyfill.js */ \"./src/misc/polyfill.js\");\n/* harmony import */ var _misc_polyfill_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_misc_polyfill_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _implementations_rx_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./implementations/rx.js */ \"./src/implementations/rx.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RxKeyboard\", function() { return _implementations_rx_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _implementations_default_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./implementations/default.js */ \"./src/implementations/default.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RKeyboard\", function() { return _implementations_default_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _keyboard_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keyboard.js */ \"./src/keyboard.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createKeyboard\", function() { return _keyboard_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n/**\n * This project is separated over multiple files:\n *\n *   - index.js: exports the general Keyboard module.\n *\n *   - events.js: adds an addKeyEventListener and a removeKeyEventListener\n *     function allowing anyone to define custom event listeners which:\n *       - only catch the keys defined in the key map.\n *       - prevent the default behavior for those keys.\n *       - avoid too much consecutive keydowns.\n *       - pass directly processed key events objects.\n *\n *   - key_catcher.js: defines a function allowing you to register and\n *     trigger callbacks on keydown / keyups with custom propagation rules.\n *\n *   - keyboard.js: defines a Keyboard factory, then used by any element\n *     wanting to perform actions on keyboard keys.\n *\n *   - implementations/*.js: multiple keyboard implementations. All based on\n *     keyboard.js.\n *\n * When starting listening to a key, the code called usually travel this way:\n * _application_ -> keyboard.js -> key_catcher.js\n *\n * When a new keyboard event arrives, the code called usually travel this way:\n * events.js -> key_catcher.js -> keyboard.js -> _application_\n */\n\n\n\n\n\nwindow.RKeyboard = _implementations_default_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = (_implementations_default_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n\n//# sourceURL=webpack://RKeyboard/./src/index.js?");

/***/ }),

/***/ "./src/key_catcher.js":
/*!****************************!*\
  !*** ./src/key_catcher.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _misc_uniq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./misc/uniq.js */ \"./src/misc/uniq.js\");\n/* harmony import */ var _misc_isSet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc/isSet.js */ \"./src/misc/isSet.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events.js */ \"./src/events.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./config.js */ \"./src/config.js\");\n\n\n\n\n/**\n * This is the KeyCatcher function.\n *\n * It returns multiple functions allowing an easy management of key events, with\n * customizable propagation rules.\n *\n * Those events are received when a user provoked a keydown or keyup event on\n * the DOM.\n *\n * It also brings the following features:\n *\n *   - \"propagation rules\" which dictate what happens when multiple callbacks\n *     are registered for the same keys.\n *\n *     I.e. Should we disable the previous callback until the new one is\n *     unregistered? Should we enable both at the same time?\n *\n *\n *   - \"re-emitting rules\" to help decide if we have to re-trigger a keydown\n *     event when a registration is done after the key was initially pushed.\n *\n *\n * @example\n * const kc = KeyCatcher();\n *\n * const myFirstCallback = ({ type, keyName, keyCode }) => {\n *   // type: 'keydown' or 'keyup'\n *   // keyName: name of the key as defined in the keyMap\n *   // keyCode: keyCode of the key pressed\n *   console.log(type, keyName, keyCode);\n *\n *   // you can directly stop the propagation to the next listening callback\n *   // this way\n *   if (keyName = 'Up') {\n *     this.stopPropagation();\n *   }\n *\n *   // you can obtain a list of all keyCodes in your key map currently pushed,\n *   // in order (last element is the last pushed)\n *   console.log(this.pushedKeyCodes); // Ex: [ 66, 24, 49 ]\n * }\n *\n * const mySecondCallback = (evt) => doSomethingWithIt(evt);\n *\n * // register keys 'Up' and 'Down'\n * kc.register(['Up', 'Down'], myFirstCallback);\n *\n * // this call will propagate 'Up' key events to the precedent one\n * kc.register(['Up', 'Left'], { propagate: true }, mySecondCallback);\n *\n * // this call will NOT propagate 'Down' key events to the precedent one\n * kc.register(['Down', 'Exit'], { propagate: false }, mySecondCallback);\n *\n * // unregister the first callback\n * kc.unregister(myFirstCallback);\n * // we could also have written:\n * // kc.unregister(['Up', 'Down'], myFirstCallback);\n * // to speed up the process\n *\n * // unregister every keys but 'Exit' from mySecondCallback\n * kc.unregister(['Up', 'Left', 'Down'], mySecondCallback);\n *\n * // unregister Exit now\n * kc.unregister(['Exit'], mySecondCallback);\n */\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (opt) {\n  if (opt === void 0) {\n    opt = {};\n  }\n\n  var keyMap = opt.keyMap || _config_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].KEY_MAP;\n  var defaultPropagate = opt.propagate || _config_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].DEFAULT_PROPAGATE_VALUE;\n  var preventDefault = opt.preventDefault || _config_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].DEFAULT_PREVENT_DEFAULT;\n  var defaultReemit = opt.reEmit || _config_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].DEFAULT_REEMIT_VALUE; // /**\n  //  * Store every keyName from every key currently held, in the right order.\n  //  * @type Array.<string>\n  //  */\n  // const KEYNAMES_PUSHED = [];\n\n  /**\n   * Store every key combination wanted.\n   * Example: [['Ctrl', 'Up'], ['a', 'b']]\n   * @type Array.Array.<string>\n   */\n\n  var KEY_COMBINATIONS = [];\n  /**\n   * Store, unitarly every key involved in a combination.\n   * Example: ['Ctrl', 'Up', 'a', 'b']\n   * @type Array.<string>\n   */\n\n  var KEY_COMBINATIONS_KEYS = [];\n  /**\n   * Create a listener.\n   * @type Object\n   */\n\n  var listener = Object(_events_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Object.keys(keyMap).map(function (x) {\n    return +x;\n  }), {\n    preventDefault: preventDefault\n  });\n  /**\n   * Here we define internal mechanisms to precisely manage propagation\n   * for the Keyboard.\n   *\n   * We create a layers object which list which key listener can listen\n   * to which key.\n   *\n   * To explain briefly how this magic works, I'm going to describe a basic\n   * usecase:\n   *\n   * Imagine that you want to listen to the key \"Up\", to perform an action when\n   * someone push it:\n   *   1. A specific callback for your keyboard call will be added to the\n   *   layers.Up Array, which will look now like that:\n   *   layers -> { Up: [ [a] ] } (where 'a' is your callback)\n   *\n   *   3. Now let's imagine that you got another keyboard call in another\n   *   component and you don't don't want the events to propagate as long as this\n   *   component is active.\n   *   You will get add another callback, but the layers object will now\n   *   change to something like:\n   *   layers -> { Up: [ [a], [b] ] } (where 'b' is your new callback)\n   *\n   *   4. Now, we have another component which do another keyboard call\n   *   but which want to propagate the call. The 'b' callback will thus be called,\n   *   but not the 'a' one as the 'b' one does not propagate. The layers\n   *   object will look something like that:\n   *   layers -> { Up: [ [a], [b, c] ] } (where 'c' is ... you understood!)\n   *\n   *   5. Now we unsubscribe the 'b' and 'c' ones. The 'a' one will now be able\n   *   again to listen to the key Up and the layers object will look again\n   *   like:\n   *   layers -> { Up: [ [a] ] }\n   *\n   *   6. You made a really complicated application which has too much\n   *   components. The layers can now look like something like that:\n   *   layers -> { Up: [ [a], [c, g, h], [i, j] ], Enter: [ [h], [i] ] }\n   *\n   *   In this last example, only the 'i' and 'j' callbacks will be called for the\n   *   key \"Up\" and only the 'i' for the key \"Enter\". As you can see, it is simply\n   *   the last array from the layers.<KEY_NAME> array which is considered\n   *   each time.\n   */\n\n  /**\n   * List callbacks for each key in an array of array.\n   * Progressively filled as callback are registered.\n   * @type Object\n   */\n\n  var layers = {}; // -- The three following variables are here for reEmit rules --\n\n  /**\n   * Object where:\n   *   - keys are keyNames\n   *   - values are the keyCodes (linked to the keyName) currently hold for\n   *     reEmitting on the last listening callback, if it wants reEmit.\n   *\n   * Changes:\n   *   - each times a keyName's top callback changes.\n   *   - each times a keyup is received for one of the keyCodes\n   * @type Object\n   */\n\n  var keyCodesMaintained = {};\n  /**\n   * Object where:\n   *   - keys are keyNames\n   *   - values are setTimeout ids currently active for re-emitting keydown\n   *     events.\n   *\n   * Changes:\n   *   - each time a keyName's top callback changes.\n   * @type Object\n   */\n\n  var reEmitTimeoutIds = {};\n  /**\n   * Link callbacks to their specific reEmit rules.\n   * Added at registration.\n   * Comes very handy when unregistering a callback and checking if the new\n   * top for a specific keyName has reEmit rules.\n   * @type WeakMap\n   */\n\n  var reEmitTimeouts = new WeakMap();\n  /**\n   * Return list of active callbacks for the corresponding key.\n   * @param {string} keyName\n   * @returns {Array.Array.<Function>}\n   */\n\n  var getActiveCatchers = function getActiveCatchers(keyName) {\n    // if keyCatchersLen is equal to a falsy value here, it means either:\n    //   1. layers.<KEY_NAME> is not defined (never be listened to yet)\n    //   2. layers.<KEY_NAME> is empty, meaning that noone is listening to\n    //      it now (even if it has been listened to).\n    var keyCatchersLen = layers[keyName] && layers[keyName].length;\n\n    if (!keyCatchersLen) {\n      return [];\n    } // get all callbacks for this keyName\n\n\n    return layers[keyName][keyCatchersLen - 1].slice(0);\n  };\n  /**\n   * Trigger every catcher callbacks for a particular key.\n   * @param {string} type - 'keydown' or 'keyup'\n   const @param {string} keyName - Key name as registered in the KeyMap. Can directly\n   * be retrieved from the keyCode but added there for simplicity.\n   * @param {Number} keyCode - KeyCode for the corresponding key. Still needed as\n   * an id, in case multiple keyCodes have the same keyName.\n   */\n\n\n  var triggerCatchers = function triggerCatchers(type, keyName, keyCode) {\n    var callbacks = getActiveCatchers(keyName); // variable set at true only the first time we loop on callbacks.\n    // Used to work arround a very specific usecase: a catcherCb being\n    // unregistered when calling another catcherCb (!)\n\n    var initial = true; // call the last callbacks registered first\n\n    for (var i = callbacks.length - 1; i >= 0; i--) {\n      /**\n       * Context given.\n       * Allow to stopPropagation when the user want, and signal supplementary\n       * informations like the list of keyCodes currently pushed.\n       * TODO find a better way for the last point, this is ugly.\n       */\n      var obj = {\n        /**\n         * Callback which stop propagating the current event.\n         */\n        stopPropagation: function stopPropagation() {\n          i = -1;\n        }\n      };\n      var callback = callbacks[i]; // callback could have been unregistered since if we are not on the\n      // initial call.\n\n      if (initial || getActiveCatchers(keyName).indexOf(callback) >= 0) {\n        callback.call(obj, {\n          type: type,\n          keyName: keyName,\n          keyCode: keyCode\n        });\n        initial = false;\n      }\n    }\n  };\n\n  var triggerCombinations = function triggerCombinations(keyCode, keyName) {\n    // if this key is involved in a combination\n    if (KEY_COMBINATIONS_KEYS.includes(keyName)) {\n      /**\n       * 2D Array ([n][3]) which contains, for each of n combinations:\n       *   1. The needed keyNames we have to check for push\n       *   2. The corresponding keyCodes as they are found\n       *   3. The combinations eligible\n       * @type Array.<Array.Array<string, Number, string>>\n       */\n      var arr = []; // 1 - get every combinations including keyName\n\n      KEY_COMBINATIONS.forEach(function (combination) {\n        var indexOf = combination.indexOf(keyName);\n\n        if (indexOf >= 0) {\n          arr.push([[].concat(combination).splice(indexOf, 1), [], [combination]]);\n        }\n      }); // 2 - second loop to find all combination completely performed\n\n      for (var i = _events_js__WEBPACK_IMPORTED_MODULE_2__[\"KEYCODES_PUSHED\"].length - 1; i >= 0; i--) {\n        if (_events_js__WEBPACK_IMPORTED_MODULE_2__[\"KEYCODES_PUSHED\"][i] !== keyCode) {\n          arr.forEach(function (m) {\n            var indexOf = m[0].indexOf(keyMap[keyCode]);\n\n            if (indexOf >= 0) {\n              m[0].splice(indexOf, 1);\n              m[1][indexOf] = keyCode;\n            }\n          });\n        }\n      } // 3 - find all combination we should trigger in order they have been\n      // asked for and trigger it.\n\n\n      arr.forEach(function (o) {\n        if (!o[0].length) {\n          var _keyCode = o[1]; // trigger each of its catchers\n\n          triggerCatchers('keydown', o[2], _keyCode);\n        }\n      });\n    }\n  };\n  /**\n   * Callback called on keydown.\n   * @param {Object} keyEvent\n   * @param {string} keyEvent.keyName\n   * @param {Number} keyEvent.keyCode\n   */\n\n\n  var onDownEvent = function onDownEvent(keyCode) {\n    var keyName = keyMap[keyCode]; // trigger each of its catchers\n\n    triggerCatchers('keydown', keyName, keyCode);\n    triggerCombinations(keyCode, keyName);\n  };\n  /**\n   * Callback called on keyup.\n   * @param {Object} keyEvent\n   * @param {string} keyEvent.keyName\n   * @param {Number} keyEvent.keyCode\n   */\n\n\n  var onUpEvent = function onUpEvent(keyCode) {\n    var keyName = keyMap[keyCode]; // if the keyCode was maintained (for reEmitting the event),\n    // stop doing it now that it's released.\n\n    var indexOf = keyCodesMaintained[keyName] && keyCodesMaintained[keyName].indexOf(keyCode);\n\n    if (indexOf >= 0) {\n      keyCodesMaintained[keyName].splice(indexOf, 1);\n    }\n\n    triggerCatchers('keyup', keyName, keyCode);\n  }; // returned object\n\n\n  var ret = {};\n  /**\n   * Register a new catcher callback for a list of keys.\n   * @param {Function} catcherCallback - The called callback each time a keyup\n   * / keydown event is received for the corresponding keys.\n   * This callback will have in arguments three values:\n   *   1. eventName {string}: 'keydown' or 'keyup' for these respective events.\n   *   2. keyName {string}: The name of the key from the key map.\n   *   3. keyCode {Number}: The keyCode for the key pushed.\n   *\n   * List of params:\n   *   - keyNames {Array.<string>} (optional) - The array of key name to listen\n   *     to.\n   *     If not set, every single key set in your keyMap will be listened to.\n   *\n   *   - propagate {Boolean} (optional) - Whether the call should be propagated.\n   *     If not set, the default value will be taken instead.\n   *\n   *   - callback {Function} - The called callback once the corresponding key\n   *     has been pushed. You can also set this callback as a second argument if\n   *     you don't want to set any propagate value.\n   *     This callback will be called with an object as argument having the\n   *     following keys:\n   *       - type {string} - 'keyup' or 'keydown'\n   *       - keyName {string} - the name of the key\n   *       - keyCode {Number} - the keyCode of the key\n   *\n   * @example\n   * const kc = KeyCatcher();\n   *\n   * kc.register(['Up', 'Down', 'Left', 'Right'], function(evt) {\n   *   switch (evt.type) {\n   *     case 'keydown':\n   *       console.log('direction button pushed:', evt.keyName);\n   *       break;\n   *     case 'keyup':\n   *       console.log('direction button released:', evt.keyName);\n   *       break;\n   *   }\n   * });\n   *\n   * // Now, the 'Up' key will be catched only by the following callback, as it\n   * // does not propagate.\n   * kc.register(['Up'], false, function() {\n   *   console.log('Up received and not propagated');\n   * });\n   *\n   * // Here we catch the 'Down' key but still propagate it to the precedent\n   * // callback for it (the first one declared here).\n   * kc.register(['Down'], true, function() {\n   *   console.log('Down received and propagated to the previous callback' +\n   *     ' declared for it');\n   * });\n   */\n\n  ret.register = function () {\n    var processArguments = function processArguments() {\n      var keyNames, propagate, reEmit, callback;\n      var argCounter = 0; // First optional argument, keyNames\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (Array.isArray(args[0])) {\n        keyNames = args[0];\n        argCounter++;\n      } // Second/first argument: options\n\n\n      if (Object(_misc_isSet_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(args[argCounter])) {\n        propagate = args[argCounter].propagate;\n        reEmit = args[argCounter].reEmit;\n      } // Last argument: callback\n\n\n      if (typeof args[args.length - 1] === 'function') {\n        callback = args[args.length - 1];\n      }\n\n      return {\n        keyNames: keyNames,\n        propagate: propagate,\n        reEmit: reEmit,\n        callback: callback\n      };\n    };\n    /**\n     * Add a new callback for a specific keyName.\n     * @param {string} keyName\n     */\n\n\n    var registerKeyListener = function registerKeyListener(keyName) {\n      // If no key are registered, link trigger to events\n      if (!Object.keys(layers).length) {\n        listener.on('keydown', onDownEvent);\n        listener.on('keyup', onUpEvent);\n      } // If you add a new key listener, you might want to re-emit\n      // keys already pressed (reEmit option).\n      // /!\\ The timeout defined here should be cleared while unregistering\n      // it.\n      // Another check is done here to see if the key was not released,\n      // relating to its keyCode\n\n\n      var reEmitTimeoutId = reEmitTimeoutIds[keyName];\n\n      if (reEmitTimeoutId) {\n        clearTimeout(reEmitTimeoutId);\n        keyCodesMaintained[keyName] = [];\n      }\n\n      if (reEmit >= 0) {\n        reEmitTimeouts.set(callback, reEmit); // if some keys are pushed\n\n        if (_events_js__WEBPACK_IMPORTED_MODULE_2__[\"KEYCODES_PUSHED\"].length) {\n          _events_js__WEBPACK_IMPORTED_MODULE_2__[\"KEYCODES_PUSHED\"].forEach(function (keyCode) {\n            if (keyMap[keyCode] === keyName) {\n              if (!keyCodesMaintained[keyName]) {\n                keyCodesMaintained[keyName] = [];\n              }\n\n              keyCodesMaintained[keyName].push(keyCode);\n            }\n          });\n          var kcsm = keyCodesMaintained[keyName]; // if our wanted key is already pressed\n\n          if (kcsm && kcsm.length) {\n            reEmitTimeoutIds[keyName] = setTimeout(function () {\n              keyCodesMaintained[keyName].forEach(function (keyCode) {\n                onDownEvent(keyCode);\n              });\n              delete keyCodesMaintained[keyName];\n            }, reEmit);\n          }\n        }\n      }\n\n      var keyArr = layers[keyName]; // if keyArr does not exist, it means that nobody has listened to this key\n      // yet. Create the array of array with the callback inside.\n\n      if (!keyArr) {\n        layers[keyName] = [[callback]];\n      } else if (propagate) {\n        var keyArrLen = keyArr.length; // if keyArrLen is equal to 0, no one is listening yet. Push just the\n        // callback.\n\n        if (!keyArrLen) {\n          keyArr.push([callback]);\n        } else {\n          // else, as we want to propagate, push the callback to the last array\n          // in keyArr.\n          keyArr[keyArrLen - 1].push(callback);\n        }\n      } else {\n        // we do not want to propagate here, push an array with only the\n        // callback at the last level.\n        keyArr.push([callback]);\n      }\n    };\n\n    var _processArguments = processArguments.apply(void 0, arguments),\n        _processArguments$key = _processArguments.keyNames,\n        keyNames = _processArguments$key === void 0 ? Object(_misc_uniq_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(Object.values(keyMap)) : _processArguments$key,\n        _processArguments$pro = _processArguments.propagate,\n        propagate = _processArguments$pro === void 0 ? defaultPropagate : _processArguments$pro,\n        _processArguments$reE = _processArguments.reEmit,\n        reEmit = _processArguments$reE === void 0 ? defaultReemit : _processArguments$reE,\n        callback = _processArguments.callback; // all arguments are mandatory, propagate just needs to be truthy/falsy\n\n\n    if (!keyNames || !callback) {\n      return;\n    }\n\n    for (var _iterator = keyNames, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var keyName = _ref;\n      registerKeyListener(keyName);\n    }\n  };\n  /**\n   * Unregister a catcher callback (it will not be called anymore for the\n   * corresponding keys).\n   *\n   * List of params:\n   *   - keyNames {Array.<string>} (optional) - The keynames you wish to delete\n   *     the callback for. If not specified, the callback will be searched for\n   *     for every keys.\n   *   - callback {Function} - The registered callback you want to unregister.\n   *     Must be the exact reference, like any removeEventListener. Can be set\n   *     as a first argument if you do not want to filter by keys.\n   *\n   * @example\n   * const someCallback = (arg) => { console.log(arg); };\n   * const kc = KeyCatcher();\n   * kc.register(['Up', 'Down'], false, someCallback);\n   *\n   * // unregister just for 'Up'\n   * kc.unregister(['Up'], someCallback);\n   *\n   * // unregister for all\n   * kc.unregister(someCallback);\n   */\n\n\n  ret.unregister = function () {\n    var processArguments = function processArguments() {\n      var _ref2;\n\n      var keyNames, callback; // First optional argument, keyNames\n\n      if (Array.isArray(arguments.length <= 0 ? undefined : arguments[0])) {\n        keyNames = arguments.length <= 0 ? undefined : arguments[0];\n      } else {\n        // take all the keys\n        keyNames = Object(_misc_uniq_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(Object.values(keyMap));\n      } // Last argument: callback\n\n\n      if (typeof (_ref2 = arguments.length - 1, _ref2 < 0 || arguments.length <= _ref2 ? undefined : arguments[_ref2]) === 'function') {\n        var _ref3;\n\n        callback = (_ref3 = arguments.length - 1, _ref3 < 0 || arguments.length <= _ref3 ? undefined : arguments[_ref3]);\n      }\n\n      return {\n        keyNames: keyNames,\n        callback: callback\n      };\n    };\n    /**\n     * Remove reference to a callback for a specific key\n     * @param {string} keyName - The key name\n     */\n\n\n    var unregisterKeyListener = function unregisterKeyListener(keyName) {\n      // if the key is not in the layers object, no one has registered to\n      // it.\n      if (!layers || !layers[keyName]) {\n        return;\n      }\n\n      var lastLayerLevel = layers[keyName].length - 1;\n\n      for (var i = lastLayerLevel; i >= 0; i--) {\n        var callbackArray = layers[keyName][i];\n        var indexOf = callbackArray.indexOf(callback);\n\n        if (indexOf >= 0) {\n          // TODO Re-facto that part, it hurts\n          // if we're speaking about the last of the last elements\n          // we should clear our reEmitTimeoutId for this key,\n          // and we may re-subscribe the precedent one if it wants\n          // reEmits\n          if (i === lastLayerLevel) {\n            // if our callback is currently the last in its layer\n            // we should update reEmitting rules.\n            if (indexOf === callbackArray.length - 1) {\n              var reEmitTimeoutId = reEmitTimeoutIds[keyName];\n\n              if (reEmitTimeoutId) {\n                clearTimeout(reEmitTimeoutId);\n                reEmitTimeoutIds[keyName] = 0;\n              } // if some keys are pushed\n\n\n              if (_events_js__WEBPACK_IMPORTED_MODULE_2__[\"KEYCODES_PUSHED\"].length) {\n                // the next callback might want reEmitting\n                var nextCallback = callbackArray[callbackArray.length - 2];\n\n                if (nextCallback) {\n                  var reEmitTimeout = reEmitTimeouts.get(nextCallback);\n                  keyCodesMaintained[keyName] = [];\n\n                  if (reEmitTimeout >= 0) {\n                    _events_js__WEBPACK_IMPORTED_MODULE_2__[\"KEYCODES_PUSHED\"].forEach(function (keyCode) {\n                      if (keyMap[keyCode] === keyName) {\n                        if (!keyCodesMaintained[keyName]) {\n                          keyCodesMaintained[keyName] = [];\n                        }\n\n                        keyCodesMaintained[keyName].push(keyCode);\n                      }\n                    });\n                    var kcsm = keyCodesMaintained[keyName]; // if our wanted key is already pressed\n\n                    if (kcsm && kcsm.length) {\n                      reEmitTimeoutIds[keyName] = setTimeout(function () {\n                        keyCodesMaintained.forEach(function (keyCode) {\n                          onDownEvent(keyCode);\n                        });\n                      }, reEmitTimeout);\n                    }\n                  }\n                }\n              }\n            }\n          } // remove callback reference from this array\n\n\n          layers[keyName][i].splice(indexOf, 1); // if the callbacks array, for the current propagation level, is now\n          // empty, delete it.\n\n          if (!callbackArray.length) {\n            layers[keyName].splice(i, 1); // if the key array is now empty, delete it.\n\n            if (!layers[keyName].length) {\n              delete layers[keyName];\n            } // if no more key events are listened to, remove event listener\n\n\n            if (!Object.keys(layers).length) {\n              listener.off('keydown', onDownEvent);\n              listener.off('keyup', onUpEvent);\n            }\n          } // we already found the callback here, there is no way that it is\n          // somewhere else for this keyName.\n\n\n          return;\n        }\n      }\n    };\n\n    var _processArguments2 = processArguments.apply(void 0, arguments),\n        keyNames = _processArguments2.keyNames,\n        callback = _processArguments2.callback; // if a mandatory param is not here, we cannot continue\n\n\n    if (!callback || !keyNames) {\n      return;\n    }\n\n    for (var _iterator2 = keyNames, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref4;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref4 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref4 = _i2.value;\n      }\n\n      var keyName = _ref4;\n      unregisterKeyListener(keyName);\n    }\n  };\n\n  ret.close = function () {\n    return listener.close();\n  };\n\n  return ret;\n});\n\n//# sourceURL=webpack://RKeyboard/./src/key_catcher.js?");

/***/ }),

/***/ "./src/keyboard.js":
/*!*************************!*\
  !*** ./src/keyboard.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _misc_isSet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./misc/isSet.js */ \"./src/misc/isSet.js\");\n/* harmony import */ var _misc_uniq_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc/uniq.js */ \"./src/misc/uniq.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events.js */ \"./src/events.js\");\n/* harmony import */ var _key_catcher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./key_catcher.js */ \"./src/key_catcher.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config.js */ \"./src/config.js\");\n// TODO:\n// V WHAT HAPPENS IF A KEY IS MAINTAINED WHILE A NON-PROPAGATING CALL COME AND GO?\n// -> REEMIT. TEST IT\n// SHOULD COMBINE DO A RELEASE? What about propagation?\n// -> No for the moment\n// COMBINATION OF KEYS: Ctrl+Up Ctrl>Up\n// TIMEPRESS when REEMIT?\n\n\n\n\n\nvar _config = config,\n    DEFAULT_COMBINE_VALUE = _config.DEFAULT_COMBINE_VALUE,\n    DEFAULT_PROPAGATE_VALUE = _config.DEFAULT_PROPAGATE_VALUE,\n    DEFAULT_REEMIT_TIMEOUT = _config.DEFAULT_REEMIT_TIMEOUT,\n    DEFAULT_PREVENT_DEFAULT = _config.DEFAULT_PREVENT_DEFAULT;\n/**\n * Defines three types of events:\n *\n *   - __push__: The key has just been pushed.\n *\n *   - __release__: The key has just been released.\n *\n *   - __press__: The key is pressed (between a 'push' and a 'release').\n *       This event is sent at intervals depending on params you gave to\n *       this listener.\n */\n\nvar EVENT_NAMES = {\n  KEY_DOWN: 'push',\n  KEY_UP: 'release',\n  KEY_PRESS: 'press'\n};\n/**\n * Keyboard factory.\n *\n * Manage complex propagation rules (propagating the same key's events to\n * multiple listening elements).\n *\n * @example\n * ```js\n * import createKeyboard from './keyboard.js';\n *\n * // creating a keyboard with its own propagation rules\n * const keyboard = createKeyboard();\n *\n * // listen to the 'Up' key events and trigger a callback as it is pushed /\n * // released\n * const upKey = keyboard('Up', (e) => {\n *    // either 'push' or 'release'\n *    console.log(e.event);\n *\n *    // 'Up' as it is the only key listened to here\n *    console.log(e.keyName);\n *\n *    // Time the key has been pushed in ms (0 for 'push' event)\n *    console.log(e.timepress);\n *\n *    // ...\n * });\n *\n * // Doing the same for multiple keys ('Up' OR 'Enter')\n * const upAndEnter = keyboard(['Up', 'Enter'], () => {\n *   // ...\n * });\n *\n * // Doing the same for all keys (we simply ignore the first argument)\n * const allKeys = keyboard((e) => {\n *   // ...\n * });\n *\n * // add custom key press rules for the 'Up' key\n * const withPress = keyboard('Up', {\n *     press: {\n *       after: 1000,\n *       interval: 2000\n *     }\n *   },\n *   (e) => {\n *     // either 'push', 'release' or 'press'\n *     console.log(e.event);\n *\n *     // ...\n *   });\n *\n * // what if we want press rules for ALL keys?\n * // We again ignore the first argument.\n * const allKeysWithPress = keyboard({\n *     press: {\n *       after: 1000,\n *       interval: 2000\n *     }\n *   },\n *   () => {\n *   });\n *\n * // -- start and stop listening to the key Up --\n *\n * // first listen to the key and store the returned object\n * const myKey = keyboard('Up');\n *\n * // executing it free the event listener\n * myKey();\n * ```\n *\n * @returns {Function} Key handling function.\n * This function only rules are:\n *   - it can take 3 arguments which can only be written in this order:\n *      1. the key(s) as a string or as an array of strings\n *      2. the options, as an object\n *      3. the callback, as a function\n *    - All of them can be ignored, undefined or null with the following\n *      effect on each one:\n *        1. all keys defined in the key map are catched\n *        2. no option is set\n *        3. no callback is set\n */\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (opt) {\n  if (opt === void 0) {\n    opt = {};\n  }\n\n  var keyMap = opt.keyMap || _config_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].KEY_MAP;\n  var groupings = opt.groupings || _config_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].GROUPINGS;\n  var defaultCombine = Object(_misc_isSet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(opt.combine) ? opt.combine : DEFAULT_COMBINE_VALUE;\n  var defaultPropagate = Object(_misc_isSet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(opt.propagate) ? opt.propagate : DEFAULT_PROPAGATE_VALUE;\n  var defaultReemit = Object(_misc_isSet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(opt.reEmit) ? opt.reEmit : DEFAULT_REEMIT_TIMEOUT;\n  var preventDefault = Object(_misc_isSet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(opt.preventDefault) ? opt.preventDefault : DEFAULT_PREVENT_DEFAULT; // Create new propagation layer from the KeyCatcher\n\n  var kc = Object(_key_catcher_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])({\n    keyMap: keyMap,\n    propagate: defaultPropagate,\n    reEmit: defaultReemit,\n    preventDefault: preventDefault\n  });\n  /**\n   * Object where:\n   *   - the keys are keyNames which are currently held, with a press option\n   *     set.\n   *   - the values are arrays contaning the corresponding keysObj (for every\n   *     listen call).\n   * Used to keep track of current presses to be able to clear them all if\n   * a new non-propagating listen is done.\n   *\n   * @type Object\n   */\n\n  var activePresses = {}; // We might need to listen events in our keyMap directly for\n  // 'Combine' rules\n\n  var listener = Object(_events_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Object.keys(keyMap).map(function (x) {\n    return +x;\n  }));\n  return {\n    listen: function listen() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      // get arguments\n      var _processArguments2 = _processArguments.apply(void 0, [groupings].concat(args)),\n          keys = _processArguments2.keys,\n          options = _processArguments2.options,\n          callbackNext = _processArguments2.callbackNext; // get after and interval options\n\n\n      var _processOptions2 = _processOptions(options),\n          pressIntervals = _processOptions2.pressIntervals,\n          _processOptions2$reEm = _processOptions2.reEmit,\n          reEmitTimeout = _processOptions2$reEm === void 0 ? defaultReemit : _processOptions2$reEm,\n          _processOptions2$prop = _processOptions2.propagate,\n          shouldPropagate = _processOptions2$prop === void 0 ? defaultPropagate : _processOptions2$prop,\n          _processOptions2$comb = _processOptions2.combine,\n          shouldCombineKeys = _processOptions2$comb === void 0 ? defaultCombine : _processOptions2$comb; // object used to know which key is pushed and when\n      // for each keycode\n\n\n      var keysObj = Object.keys(keyMap) // Only consider listened key\n      .filter(function (keyCode) {\n        return keys.includes(keyMap[keyCode]);\n      }) // construct the keyObj object\n      .reduce(function (vals, key) {\n        vals[key] = {\n          // name of the key\n          keyName: keyMap[key],\n          // true if currently pushed\n          isPushed: false,\n          // timestamp of push start (null if not currently pushed)\n          pushStart: null,\n          // current press interval step. 1 is the first step.\n          currentPressInterval: 0,\n          // store a setInterval's return for press events\n          interval: null,\n          // store setTimeouts return for press events\n          timeouts: []\n        };\n        return vals;\n      }, {});\n      /**\n       * Clear current timeouts and/or interval for a specific key object.\n       * @param {Object} keyObj\n       * @param {Number|null} keyObj.timeouts\n       * @param {Number|null} keyObj.interval\n       */\n\n      var clearKeyTimeouts = function clearKeyTimeouts(keyObj) {\n        // 1 - clear timeouts\n        keyObj.timeouts.forEach(function (t) {\n          return clearTimeout(t);\n        });\n        keyObj.timeouts = []; // 2 - clear intervals\n\n        if (keyObj.interval) {\n          clearInterval(keyObj.interval);\n          keyObj.interval = 0;\n        } // 3 - remove from activePresses object\n\n\n        if (activePresses[keyObj.keyName]) {\n          var keyActivePresses = activePresses[keyObj.keyName];\n          var indexOf = keyActivePresses.indexOf(keyObj);\n          activePresses[keyObj.keyName].splice(indexOf, 1);\n\n          if (!keyActivePresses.length) {\n            delete activePresses[keyObj.keyName];\n          }\n        }\n      };\n      /**\n       * Send 'push' event for the given key object (property from the keysObj\n       * object).\n       * @param {Object} keyObj\n       */\n\n\n      var sendPushEvent = function sendPushEvent(ctx, keyObj) {\n        var keyName = keyObj.keyName;\n        callbackNext.call(ctx, {\n          keyName: keyName,\n          event: EVENT_NAMES.KEY_DOWN,\n          pressInterval: 0,\n          timepress: 0\n        });\n      };\n      /**\n       * Send 'press' event for the given key object (property from the keysObj\n       * object).\n       * @param {Object} keyObj\n       */\n\n\n      var sendPressEvent = function sendPressEvent(ctx, keyObj) {\n        var keyName = keyObj.keyName,\n            currentPressInterval = keyObj.currentPressInterval,\n            pushStart = keyObj.pushStart;\n        var timepress = Object(_misc_isSet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(pushStart) ? performance.now() - pushStart : 0;\n        callbackNext.call(ctx, {\n          keyName: keyName,\n          event: EVENT_NAMES.KEY_PRESS,\n          pressInterval: currentPressInterval,\n          timepress: timepress\n        });\n      };\n      /**\n       * Send 'release' event for the given key object (property from the keysObj\n       * object).\n       * @param {Object} keyObj\n       */\n\n\n      var sendReleaseEvent = function sendReleaseEvent(ctx, keyObj) {\n        var keyName = keyObj.keyName,\n            currentPressInterval = keyObj.currentPressInterval,\n            pushStart = keyObj.pushStart;\n        var timepress = Object(_misc_isSet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(pushStart) ? performance.now() - pushStart : 0;\n        callbackNext.call(ctx, {\n          keyName: keyName,\n          event: EVENT_NAMES.KEY_UP,\n          pressInterval: currentPressInterval,\n          timepress: timepress\n        });\n      };\n      /**\n       * Generic callback for new key events.\n       * Given to the registerCatcher function.\n       *\n       * If the key is listened to, dispatch the event to:\n       *   - onDownEvent if a 'keydown' event has been received\n       *   - onUpEvent if a 'keyup' event has been received\n       * with the right key object (element from the keysObj array).\n       *\n       * @see registerCatcher\n       * @see onDownEvent\n       * @see onUpEvent\n       * @param {Object} evt\n       * @param {string} evt.type - 'keyup' or 'keydown'\n       * @param {string} evt.keyName\n       * @param {Number} evt.keyCode\n       */\n\n\n      var onEvent = function onEvent(evt) {\n        // if keyName is not listened to, abort\n        if (!keys.includes(evt.keyName)) {\n          return;\n        }\n\n        switch (evt.type) {\n          case 'keydown':\n            onDownEvent(this, evt);\n            break;\n\n          case 'keyup':\n            onUpEvent(this, evt);\n            break;\n        }\n      };\n\n      var startPressEvents = function startPressEvents(ctx, keyObj) {\n        // start press timeouts + interval\n        if (Object(_misc_isSet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(pressIntervals)) {\n          // Update activePresses to add this keyObj reference to it.\n          var keyActivePresses = activePresses[keyObj.keyName];\n          activePresses[keyObj.keyName] = keyActivePresses ? keyActivePresses.push(keyObj) : [keyObj];\n          /**\n           * Set timeout and interval for a single pressInterval.\n           * Update keyObj.interval and keyObj.pressInterval accordingly.\n           * Returns the setTimeout's ID.\n           * @param {Object} pressInterval\n           * @param {Number} pressInterval.after\n           * @param {Number} [pressInterval.interval]\n           * @returns {Number} - setTimeout's ID.\n           */\n\n          var constructTimeout = function constructTimeout(pressInterval) {\n            return setTimeout(function () {\n              // 1 - clear possible previous interval\n              if (keyObj.interval) {\n                clearInterval(keyObj.interval);\n              } // 2 - if an interval is set do a setInterval for key presses.\n              // Reset keyObj.interval otherwhise\n\n\n              if (Object(_misc_isSet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(pressInterval.interval)) {\n                keyObj.interval = setInterval(function () {\n                  sendPressEvent(ctx, keyObj);\n                }, pressInterval.interval);\n              } else {\n                keyObj.interval = null;\n              } // 3 - send initial press event\n\n\n              keyObj.currentPressInterval++;\n              sendPressEvent(ctx, keyObj);\n            }, pressInterval.after);\n          }; // launch every interval here (doing every setTimeout synchronously is\n          // more reliable than doing one by one)\n\n\n          pressIntervals.forEach(function (pressInterval) {\n            keyObj.timeouts.push(constructTimeout(pressInterval));\n          });\n        }\n      };\n      /**\n       * Callback called when a 'keydown' event was received for a particular\n       * key object (keyObj param).\n       *\n       * If the key is not already pushed:\n       *   1. Begin timeouts and/or interval for press events if specified.\n       *   2. Set right data on the key object\n       *   3. Trigger a push event for the key\n       * @param {Object} kcCtx - The keyCatcher's context. Used for\n       * stopPropagation function.\n       * @param {Object} keyObj - The key object\n       */\n\n\n      var onDownEvent = function onDownEvent(kcCtx, _ref) {\n        var keyCode = _ref.keyCode;\n        var keyObj = keysObj[keyCode]; // if it is already pushed, abort\n\n        if (keyObj.isPushed) {\n          return;\n        } // if this keydown is not for the last key pushed, abort.\n        // (registration can be done after some keys have been pushed, and we\n        // could have set a reEmit timeout)\n\n\n        if (_events_js__WEBPACK_IMPORTED_MODULE_2__[\"KEYCODES_PUSHED\"][_events_js__WEBPACK_IMPORTED_MODULE_2__[\"KEYCODES_PUSHED\"].length - 1] !== keyCode) {\n          return;\n        } // context with which the callback will be called\n\n\n        var cbCtx = {\n          stopPropagation: kcCtx.stopPropagation\n        }; // start press events if wanted\n\n        startPressEvents(cbCtx, keyObj); // set keyObj data\n\n        keyObj.isPushed = true;\n        keyObj.pushStart = performance.now(); // send initial push event\n\n        sendPushEvent(cbCtx, keyObj);\n      };\n      /**\n       * Callback called when a 'keyup' event was received for a particular\n       * key object (keyObj param).\n       *\n       * If the key is considered already pushed:\n       *   1. clear timeouts and/or interval for press events if specified.\n       *   2. Trigger a release event for the key\n       *   2. Set right data on the key object\n       * @param {Object} keyObj - The key object\n       */\n\n\n      var onUpEvent = function onUpEvent(kcCtx, _ref2) {\n        var keyCode = _ref2.keyCode;\n        var keyObj = keysObj[keyCode]; // if no push event has been received, don't send release events\n        // (this can happen if the key was pushed while we were not listening)\n\n        if (!keyObj.isPushed) {\n          return;\n        }\n\n        clearKeyTimeouts(keyObj); // context with which the callback will be called\n\n        var cbCtx = {\n          stopPropagation: kcCtx.stopPropagation\n        };\n        sendReleaseEvent(cbCtx, keyObj);\n        keyObj.isPushed = false;\n        keyObj.pushStart = null;\n      }; // if we do not want to combine keys, on any keyCode keydown event,\n      // clear press timeouts for every key already pressed.\n\n\n      var onAnyKeyDown;\n\n      if (!shouldCombineKeys) {\n        onAnyKeyDown = function onAnyKeyDown() {\n          Object.values(keysObj).forEach(function (k) {\n            return clearKeyTimeouts(k);\n          });\n        };\n\n        listener.on('keydown', onAnyKeyDown);\n      } // if the newly defined listened key must not be propagated,\n      // we have to stop emitting key presses for them.\n\n\n      if (!shouldPropagate) {\n        keys.forEach(function (keyName) {\n          if (activePresses[keyName]) {\n            activePresses[keyName].forEach(function (keyObj) {\n              clearKeyTimeouts(keyObj);\n            });\n          }\n        });\n      }\n\n      kc.register(keys, {\n        propagate: shouldPropagate,\n        reEmit: reEmitTimeout\n      }, onEvent);\n      return function () {\n        if (!shouldCombineKeys) {\n          listener.off('keydown', onAnyKeyDown);\n        } // clear timeouts for every key\n\n\n        for (var _i = 0, _Object$keys = Object.keys(keysObj); _i < _Object$keys.length; _i++) {\n          var key = _Object$keys[_i];\n          clearKeyTimeouts(keysObj[key]);\n        } // clear catchers\n\n\n        kc.unregister(keys, onEvent);\n      };\n    },\n    close: function close() {\n      kc.close();\n    }\n  };\n});\n/**\n * Retrieve arguments (keys + options + callback).\n * undefined if not defined/null/ignored.\n * @param {Array.<string>} groupings\n * @param {...*} [args]\n * @return {Object} obj\n * @returns {Array.<string>|undefined} obj.keys - Every key names listened to.\n * Groupings are browsed to only include real key names.\n * @returns {Object|undefined} obj.options\n * @returns {Function|undefined} obj.callbackNext\n */\n\nvar _processArguments = function _processArguments(groupings) {\n  var keysArg; // key names\n\n  var optionsArg;\n  var callbackArg;\n  /**\n   * Browse Groupings to be sure only key names are returned.\n   * @param {Array.<string>} names\n   * @returns {Array.<string>}\n   */\n\n  var getKeysFromNames = function getKeysFromNames(names) {\n    return names.reduce(function (kns, name) {\n      if (Object.keysArg(groupings).includes(name)) {\n        return kns.concat(groupings[name]);\n      }\n\n      kns.push(name);\n      return kns;\n    }, []);\n  };\n\n  var argsLen = arguments.length <= 1 ? 0 : arguments.length - 1;\n  var argId = 0;\n  var arg = argId + 1 < 1 || arguments.length <= argId + 1 ? undefined : arguments[argId + 1];\n\n  if (Array.isArray(arg)) {\n    keysArg = getKeysFromNames(arg);\n    argId++;\n    arg = argId + 1 < 1 || arguments.length <= argId + 1 ? undefined : arguments[argId + 1];\n  } else if (typeof arg === 'string') {\n    keysArg = getKeysFromNames([arg]);\n    argId++;\n    arg = argId + 1 < 1 || arguments.length <= argId + 1 ? undefined : arguments[argId + 1];\n  } else if (!Object(_misc_isSet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(arg) && argsLen - 1 > argId) {\n    argId++;\n    arg = argId + 1 < 1 || arguments.length <= argId + 1 ? undefined : arguments[argId + 1];\n  }\n\n  if (typeof arg === 'object' && arg !== null) {\n    optionsArg = arg;\n    argId++;\n    arg = argId + 1 < 1 || arguments.length <= argId + 1 ? undefined : arguments[argId + 1];\n  } else if (!Object(_misc_isSet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(arg) && argsLen - 1 > argId) {\n    argId++;\n    arg = argId + 1 < 1 || arguments.length <= argId + 1 ? undefined : arguments[argId + 1];\n  }\n\n  if (typeof arg === 'function') {\n    callbackArg = arg;\n  }\n\n  var keys = Object(_misc_isSet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(keysArg) ? keysArg : Object(_misc_uniq_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Object.values(keyMap));\n  var options = Object(_misc_isSet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(optionsArg) ? optionsArg : {};\n  var callbackNext = Object(_misc_isSet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(callbackArg) ? callbackArg : function () {};\n  return {\n    keys: keys,\n    options: options,\n    callbackNext: callbackNext\n  };\n};\n/**\n * Insertion sort algorithm for pressIntervals.\n * Insertion sort is preferred here as:\n *   1. The array is most probably already sorted by the caller\n *   2. The length of the Array have a high chance of being (very) small\n * /!\\ Mutate the given array\n * @param {Array.<Object>} pressIntervals\n * @returns {Array.<Object>}\n */\n\n\nvar _sortPressIntervals = function _sortPressIntervals(pressIntervals) {\n  var len = pressIntervals.length;\n\n  for (var i = 0; i < len; i++) {\n    // That does not look like an efficient way of doing it, but it doesn't\n    // matter here\n    pressIntervals[i] = {\n      after: +pressIntervals[i].after,\n      interval: +pressIntervals[i].interval\n    };\n\n    if (isNaN(pressIntervals[i].after)) {\n      if (!isNaN(pressIntervals[i].interval)) {\n        // In our case: { interval: 100 } == { press: 100, interval: 100 }\n        pressIntervals[i].after = pressIntervals[i].interval;\n      } else {\n        // we have neither an after nor an interval, splice\n        // it as it is an invalid pressIntervals\n        pressIntervals.splice(i, 1);\n        i--;\n        continue;\n      }\n    } else if (isNaN(pressIntervals[i].interval)) {\n      delete pressIntervals[i].interval;\n    }\n\n    var j = i;\n\n    while (j > 0 && pressIntervals[j - 1].after > pressIntervals[j].after) {\n      var tmp = pressIntervals[j];\n      pressIntervals[j] = pressIntervals[j - 1];\n      pressIntervals[j - 1] = tmp;\n    }\n  }\n\n  return pressIntervals;\n};\n/**\n * Retrieve press options from the options arguments.\n * @param {Object} options - options as returned by _processArguments.\n * @returns {Object} opts - options as returned by\n * @returns {Number} [opts.after] - Time (after a keydown event) after which\n * a key press is triggered. Without this param, no press is possible.;\n * @returns {Number} [opts.interval] - Interval (after 'after') on which the\n * press event is triggered. If not set, no press event interval is set.\n * @returns {Boolean} opts.propagate - wether the keyboard call is\n * propagated to the next one or not.\n */\n\n\nvar _processOptions = function _processOptions(options) {\n  var pressIntervals, reEmit;\n  var propagateOpt = options.propagate,\n      combineOpt = options.combine,\n      reEmitOpt = options.reEmit,\n      pressOpt = options.press;\n\n  if (Object(_misc_isSet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(pressOpt)) {\n    if (Array.isArray(pressOpt)) {\n      pressIntervals = _sortPressIntervals(pressOpt);\n    } else {\n      var afterOpt = +pressOpt.after;\n      var intervalOpt = +pressOpt.interval;\n\n      if (isNaN(afterOpt)) {\n        if (!isNaN(intervalOpt)) {\n          // In our case: { interval: 100 } == { press: 100, interval: 100 }\n          pressIntervals = [{\n            after: intervalOpt,\n            interval: intervalOpt\n          }];\n        }\n      } else if (isNaN(intervalOpt)) {\n        pressIntervals = [{\n          after: afterOpt\n        }];\n      } else {\n        pressIntervals = [{\n          after: afterOpt,\n          interval: intervalOpt\n        }];\n      }\n    }\n  }\n\n  if (Object(_misc_isSet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(reEmitOpt)) {\n    var reEmitNum = +reEmitOpt;\n\n    if (!isNaN(reEmitNum)) {\n      reEmit = reEmitNum;\n    }\n  }\n\n  return {\n    pressIntervals: pressIntervals,\n    combine: combineOpt,\n    reEmit: reEmit,\n    propagate: propagateOpt\n  };\n};\n\n//# sourceURL=webpack://RKeyboard/./src/keyboard.js?");

/***/ }),

/***/ "./src/misc/isSet.js":
/*!***************************!*\
  !*** ./src/misc/isSet.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Returns true if the variable given is not null nor undefined.\n * @example isSet(false) => true\n * @example isSet(0) => true\n * @example isSet(null) => false\n * @example isSet('toto') => true\n * @example isSet(undefined) => false\n * @param {*} x\n * @returns {Boolean}\n */\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (x) {\n  return x != null;\n});\n\n//# sourceURL=webpack://RKeyboard/./src/misc/isSet.js?");

/***/ }),

/***/ "./src/misc/polyfill.js":
/*!******************************!*\
  !*** ./src/misc/polyfill.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// babel did not add that one to the es2017 plugin\n// TODO ponyfill instead?\nObject.values = Object.values || function (obj) {\n  return Object.keys(obj).map(function (x) {\n    return obj[x];\n  });\n};\n\n//# sourceURL=webpack://RKeyboard/./src/misc/polyfill.js?");

/***/ }),

/***/ "./src/misc/uniq.js":
/*!**************************!*\
  !*** ./src/misc/uniq.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Returns only unique values from an array.\n * @example uniq([1, 2, 1]) => [1, 2]\n * @example uniq([9, 2, 3, 4, 3, 5]) => [9, 2, 3, 4, 5]\n * @param {Array} x\n * @returns {Array}\n */\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (x) {\n  return [].concat(new Set(x));\n});\n\n//# sourceURL=webpack://RKeyboard/./src/misc/uniq.js?");

/***/ })

/******/ });
});